<html>
<head>
  <title>Schampignon</title>
  <script src="jsparse.js" type="text/javascript"></script>
  <script src="schampignon.js" type="text/javascript"></script>
</head>
<body>
  <div id="output">
  </div>
  <form id="evalform" onsubmit="return do_eval()">
    <input type="text" name="input">
    <input type="submit" value="eval">
  </form>
  <script type="text/javascript">
var ground_env = scm_make_env();
scm_update(ground_env, "$define!", new Scm_define());
scm_update(ground_env, "$vau", new Scm_vau());
scm_update(ground_env, "$if", new Scm_if());
scm_update(ground_env, "eval", scm_wrap(new Scm_eval()));
scm_update(ground_env, "wrap", scm_make_native(scm_wrap));
scm_update(ground_env, "unwrap", scm_make_native(scm_unwrap));
scm_update(ground_env, "null?", scm_make_native(scm_nullp));
scm_update(ground_env, "car", scm_make_native(scm_car));
scm_update(ground_env, "cdr", scm_make_native(scm_cdr));
scm_update(ground_env, "cons", scm_make_native(scm_cons));
scm_update(ground_env, "make-environment", scm_make_native(scm_make_env));
scm_update(ground_env, "#t", true);
scm_update(ground_env, "#f", false);
scm_update(ground_env, "%ignore", {});
scm_update(ground_env, "%inert", {});
scm_update(ground_env, "print", scm_make_native(do_print));

var vm = new Scm_vm(scm_make_env(ground_env));

function do_eval()
{
  var forms = scm_parse(document.forms.evalform.input.value);
  do_print("> " + document.forms.evalform.input.value);
  for (var i = 0; i < forms.length; i++) {
    var form = forms[i];
    var result;
    try {
//      do_print("PARSE: " + JSON.stringify(form));
      result = scm_eval(vm, form);
    } catch(e) {
      result = "ERROR: " + e;
    }
    do_print(result);
  }
  return false;
}

function do_print(string)
{
    var resultDiv = document.createElement("div");
    resultDiv.appendChild(document.createTextNode(string));
    document.getElementById("output").appendChild(resultDiv);
    document.forms.evalform.input.value = "";
    return false;
}
  </script>
<p>Some sample code for playing
<pre>
($define! $sequence
   ((wrap ($vau ($seq2) %ignore
             ($seq2
                ($define! $aux
                   ($vau (head . tail) env
                      ($if (null? tail)
                           (eval head env)
                           ($seq2
                              (eval head env)
                              (eval (cons $aux tail) env)))))
                ($vau body env
                   ($if (null? body)
                        %inert
                        (eval (cons $aux body) env))))))

      ($vau (first second) env
         ((wrap ($vau %ignore %ignore (eval second env)))
          (eval first env)))))

($define! list (wrap ($vau x %ignore x)))

($define! list*
   (wrap ($vau args %ignore
            ($sequence
               ($define! aux
                  (wrap ($vau ((head . tail)) %ignore
                           ($if (null? tail)
                                head
                                (cons head (aux tail))))))
               (aux args)))))

($define! $vau
   ((wrap ($vau ($vau) %ignore
             ($vau (formals eformal . body) env
                (eval (list $vau formals eformal
                           (cons $sequence body))
                      env))))
      $vau))

($define! $lambda
   ($vau (formals . body) env
      (wrap (eval (list* $vau formals %ignore body)
                  env))))

($define! apply
   ($lambda (appv arg . opt)
      (eval (cons (unwrap appv) arg)
            ($if (null? opt)
                 (make-environment)
                 (car opt)))))

($define! $cond
   ($vau clauses env

      ($define! aux
         ($lambda ((test . body) . clauses)
            ($if (eval test env)
                 (apply (wrap $sequence) body env)
                 (apply (wrap $cond) clauses env))))

      ($if (null? clauses)
           %inert
           (apply aux clauses))))

(car (list 1 2 3))

($sequence (print 1) (print 2) (print 3))

</pre>
</body>
</html>
